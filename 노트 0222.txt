dx = [1,
dy = [0
기존 문제를 다시 풀
거품/선택 정렬
기본형 ->기본형+응용
트리 하나가 여러 개와 이어질 수 있다
계층형자료구조입니다 상위->하위로 확장되는 구조
용어에대한설명
한개이상의노드로이뤄짐
최상위 노드(vertex)를 루트라 칭함
노드/간선/부모와 자식 노드
간선을 기준해서 더 위에 있으면 부모, 아래는 자식
서브트리에 속하면 모두 자손노드
상위에 엣지로 연결된 모든 조상 노드
노드차수/트리차수
차수가 없는 노드,자식노드가 없는 노드
루트의 높이 상대적인 개념
루트노드를 레벨 1로 놓는가 레벨 0으로 놓는가에 따라 식이 달라진다
이진트리
각 노드가 자식을 최대 둘 까지만 가질 수 있는 트리
루트노드 레벨이 0 인 때에 레벨 i에서는 최대 노드 갯수가 2^i개
최소 노드의 갯수는 높이h에서 h+1 최대 갯수는
2^(h+1)-1
포화이진트리
모든 레벨에서 노드가 꽉 찬 이진트리
높이 h 에서 2^(h+1)-1 의 최대 노드수를 가진다
루트노드 레벨이 0일 때에 레벨i에서의 노드 수는 2^i개
완전이진트리
노드 수가 정해져 있으며,노드 수를 만족할 때 까지는 빈 자리 없이 포화인 트리
정해진 노드 수 = n ->
2^h<=n<=2^(h+1) -1 ((2^h차이에 최소 1개 차있으므로 -1만큼 차이남)
h-1레벨까지는 꽉 차 있고, h레벨에서 최소 한개이상이므로 2^(h-1+1)
편향이진트리
한쪽 방향의 자식노드만을 가지고, 높이h에서는 최소개수의 노드를 갖는다
선형자료
이진트리의 순회
내가 지금 현재 트리의 루트에 접근하면 이진트리는 왼쪽/오른쪽 
전위순회
부모노드-왼쪽자식노드-오른쪽자식노드 
중위순회
왼쪽자식노드-부모노드-오른쪽자식노드
후위순회
왼쪽자식-오른쪽자식노드-부모가가장마지막에처리
노드 번호의 성질
노드번호가 i인 노드의 부모노드 번호 i/2
노드번호가 i인 노드의 왼쪽 자식 노드 번호 2*i
오른쪽은 (2*i)+1
포화이진트리가 아니라면
이진 트리에서
간선갯수 4
노드는 언제나 간선갯수 +1

트리는 순환하지 않음
처음에 1번의 
for i : 1 -> N
	read p,c
	if(c1[p] == 0)
		c1[p] =c
	else
		c2[p] =c

root는 부모가 0 이거나 -1인경우를
c=5
while(a[c] != 0) #부모루트값인 0인지 확인
	c= a[c] #첫 c의 값인 5가 부모 노드로 새로 지정됨(이 경우 3)
	anc.append(c) #조상 목록
	root =c


저번 주에 배웠던 내용 - queue
선입 선출을 기조로 함 FIFO
선형queue 원형 queue
*우선순위 queue
선입선출 아님 우선순위에 따른 나가는 순서
(내부 구조를 heap으로 하고 있음.[heapq])
bfs: dfs와 다르게 queue를 사용하고,pop(0) 한다

트리 구조
가족-형제 구성도
DFS, BFS 도식화는 트리 구조와 동일
부모 노드의 존재, 자식 노드N개가 있으면(1:N)관계라면 -> 트리 구조를 뜻함
(모든 노드에 대해서 이러한 구조가 적용되어야 함)
최상단에는 root node 단 하나만 존재
트리-sub트리
차수 - 하나의 부모 노드에 대해서 얼마나 자식 노드를 갖는가
부모노드 레벨 +1 에서의 자식만을 따짐
트리의 차수 - 노드의 차수 중에서 가장 큰 값
단말노드(leaf노드)-차수가0=자식노드가 없는 노드
높이 

이진 트리
최대 자식노드가 1개 부모노드 당 2개 까지 허용하는 트리
최대 자식이 0개인 부모노드 1개로 이뤄진 트리도 이진트리의 한 갈래

포화 이진트리
높이 h에서 최대한의 노드갯수인 2^n -1 을 갖는 트리
완전 이진트리
높이 -1 까지는 포화 이진트리이지만, 높이h에서의 노드는 최소 1개만을 갖는 이진 트리
편향 이진트리
한쪽으로만 뻗은 이진 트리

순회
트리 안의 노드를 방문
전위 - 부모->좌->우 순서
def preorder_traverse(T):
	if T : #트리가 비어있지 않다면
		visit(T)
		preorder_traverse(T.left)
		preorder_traverse(T.right)
(순서 - root노드 1부터 시작 1-2-4-5-8-9-3-6-7)

중위 - 좌->부모->우 순서
def inorder_traverse(T):
	if T:
	visit(T)
	inorder_traverse(T.left)
	visit(T)
	inorder_travers(T.right)
(최좌측부터 시작 4-2-8-5-9-1-6-3-7)

후위
최좌측 자식노드부터 - 우측자식노드-부모노드
def postorder_traverse(T):
	if T:
		postorder_traverse(T->left)
		postorder_traverse(T->right)
		visit(T)
A-B-D-H-I-E-J-C-F-K-G-L-M
H-D-I-B-J-E-A-F-K-C-L-G-M (pre : FCK)
H-I-D-J-E-B-K-F-L-M-G-C-A

H-D-I-B-J-E-A-F-K-C-L-G-M

이진트리에서 부모 노드 탐색을 위해서는 부여받은 인덱스//2 하면 부모 노드를 찾을 수 있다.
이런 규칙성을 통해 일차원배열로 이진 트리를 구현가능함
node = {0:0, 1:A, 2:B, 3:C, 4:D, 5:E, 6:F, 7:G, 8:H, 9:I, 10:J}
높이가 3인 이진 트리를 위한 배열크기는? 2^3
레벨 i의 최대 노드 수는?
편향 트리의 경우에는 배열에서 빈 칸이 많아 낭비 발생
1.부모 번호를 인덱스로 자식 번호를 저장
부모   0 1 2 3 4 5  여기의 값이 부모일 때에
자식1 0 2 0 4 0 0  자식 노드로 뭘 갖는가(좌측)
자식2 0 3 0 5 0 0	자식 노드로 뭘 갖는가(우측)
2.자식 번호를 인덱스로 부모 번호를 저장하는 방법
자식c 0 1 2 3 4 5 여기의 값이 자식일 때에,
부모a 0 0 1 1 3 3 해당 자식 노드가 부모로 어떤 노드를 갖는가?
자식c = 5 에서 부모는 3이므로 3으로 가고,
자식c= 3에서 부모는 1 이므로 1로 간다.
자식c =1에서는 부모가 없으므로 1은 루트 노드임을 알 수 있다.
배열을 이용한 이진트리 표현의 단점
편향트리에서 낭비되는 메모리 많다
트리를 편집했을 때에 배열 낭비가 크다

BFS/DFS/순회(선,중,후)
ex) 해당 노드의 인접 값이 0이 아니면, 
cnt +=1 씩 하면서 

