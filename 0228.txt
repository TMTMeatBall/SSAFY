&는 정의는 a,b/a&b -> 00:0/01:0/10:0/11:1 #논리 and 연산
비트 검사, 특정 비트를 0으로 할 때에 사용
ex)1011 & 1101 = 1001
|(shift+\) : or 연산을 실행함
00 0 01 1 10 1 11 1
ex) 0011 | 1000 = 1011
^ : 비트 단위의 XOR연산(같으면 0 다르면 1)을 함
00 0 01 1 10 1 11 0*
ex) 0101 ^ 0110 = 0011
~ : 피연산자 비트를 반전
ex) ~0011 = 1100
<< : 피연산자 비트 열의 좌측 이동
>> : 반대

1<<n : 2^n
원소가 n개일 경우에 각 원소별로 포함/포함x의 두 가지 경우를
생각하는 부분집합의 수
(공집합,자기자신을 포함한다)

i & (1<<j) :i의 j번째 비트가 1인지 아닌지를 의미
연산결과가 0이면 j비트는 0

비트 연산의 예제
#교재, pycharm확인

엔디안
리틀 엔디안 방식이 거의 통일됨
메모리 넘버에서 낮은 자리의 수가 메모리의 상층부에 위치함
실제 다룰 때는 같이 저장된 것으로 취급함

진수 - 2/8/10/16...
10진수 -> 타 진수로 전환
원하는 타 진수의 수로 나눈 뒤의 매 경우 나머지를 거꾸로 출력

타 진수에서의 실수 표현
ex)2진수에서 0.1 = 2^-1
(0.1)^n = 2^-n 

input() 함수는 표준 입력에서 한 줄을 읽어들인다는 점에서는 모두 동일합니다. 그러나 반환되는 값의 형태는 다릅니다.

input().strip(): 표준 입력에서 읽어들인 한 줄의 문자열을 반환하되, 문자열 앞 뒤의 공백 문자를 제거합니다. 따라서 문자열 중간에 있는 공백 문자는 그대로 유지됩니다. 예를 들어, " hello world! "를 입력으로 받았다면 "hello world!"를 반환합니다.
input().split(): 표준 입력에서 읽어들인 한 줄의 문자열을 반환하되, 문자열을 공백 문자(스페이스, 탭, 개행 등)로 분리하여 리스트로 만듭니다. 예를 들어, "hello world!"를 입력으로 받았다면 ["hello", "world!"]를 반환합니다.
input(): 표준 입력에서 읽어들인 한 줄의 문자열을 그대로 반환합니다. 따라서 문자열 앞 뒤의 공백 문자는 그대로 유지되며, 문자열 중간에 있는 공백 문자도 그대로 유지됩니다. 예를 들어, " hello world! "를 입력으로 받았다면 " hello world! "를 반환합니다.
이렇게 반환된 값의 형태에 따라 이후의 처리 방법이 달라질 수 있습니다. 예를 들어, input().strip()으로 입력된 문자열을 split()으로 분리하여 리스트를 만들어야 할 때는 다음과 같이 작성할 수 있습니다.
map(int,input().split()) : 인풋값을 split()의 입력에 따른 분리하고 리스트 반환한 것에 map함수로 int()를 모든 리스트 안의 요소에 적용함(정수로 형태 변환)

*파이썬에서의 언더바(_)의 사용례 정리하기
1.2.3.4.5.


복잡도 분석 : O(상한) 오메가(하한) 세타(평균)
표준 입출력 방식 input,print,파일입출력(import std, sys stdin sys stdout )
비트 연산 : |(or) &(and) ^(xor) num<<2 num>>2
0101(2)=5(10) <<2 : 010100(2) = 20(10)
0101(2)=5(10) >>2 : 01.01(2) = 1.25(10)

진수 변환 - 원하는 진수로 나눠가면서 몫이 0이 될 때까지
while num>0: 를 사용해서 몫, 나머지를 저장하고, 반환함
divmod(num,n) 를 사용
RGB(16)에서
black(ff,ff,ff)는 16*16,16*16,16*16 이므로 255,255,255 이다

컴퓨터에서 음수를 표현하는 방식
0000000111100000011000000111100110000110000111100111100111111001100111
01D06079861D79F99F
0269FAC9A0
실수 표현 float()
